% Generate QDFE-ratio quadrature
function quadrature = QDFEratioBS(squareInfo, iRef)

% Retrieve needed square properties
minSubX      = squareInfo.minSubX;
minSubY      = squareInfo.minSubY;
maxSubX      = squareInfo.maxSubX;
maxSubY      = squareInfo.maxSubY;
minSubSubX   = squareInfo.minSubSubX;
maxSubSubX   = squareInfo.maxSubSubX;
minSubSubY   = squareInfo.minSubSubY;
maxSubSubY   = squareInfo.maxSubSubY;
surfaceArea  = squareInfo.surfaceArea;
integrations = squareInfo.integrations;

% Initialize storage
xPos    = cell((iRef + 1) ^ 2, 1);
yPos    = cell((iRef + 1) ^ 2, 1);
gamma   = cell((iRef + 1) ^ 2, 3);
theta   = cell((iRef + 1) ^ 2, 3);
weights = cell((iRef + 1) ^ 2, 1);

% Define iteration parameters
areaEps   = 1e-15;
maxCounts = 10000;

% Fixed side ratio
ratio_side = 0.7;

counterPlot = 1;
% Go through each sub-square
for iSub = 1 : (iRef + 1) ^ 2
    
    % Upper bound guess
    ratio_a = 0.5;
    
    % Lower bound guess
    ratio_b = 0.6;
    
    % Solve initial weights for a ratio
    subSubLengthX = (maxSubX(iSub) - minSubX(iSub)) / 3;
    subSubLengthY = (maxSubY(iSub) - minSubY(iSub)) / 3;
    %{
    xPosTemp = [maxSubSubX{iSub}(1) - subSubLengthX * ratio_a, ...
               (maxSubSubX{iSub}(2) + minSubSubX{iSub}(2)) / 2, ...
                minSubSubX{iSub}(3) + subSubLengthX * ratio_a, ...
                maxSubSubX{iSub}(4) - subSubLengthX * ratio_side, ...
               (maxSubSubX{iSub}(5) + minSubSubX{iSub}(5)) / 2, ...
                minSubSubX{iSub}(6) + subSubLengthX * ratio_side, ...
                maxSubSubX{iSub}(7) - subSubLengthX * ratio_a, ...
               (maxSubSubX{iSub}(8) + minSubSubX{iSub}(8)) / 2, ...
                minSubSubX{iSub}(9) + subSubLengthX * ratio_a];
    yPosTemp = [maxSubSubY{iSub}(1) - subSubLengthY * ratio_a, ...
                maxSubSubY{iSub}(2) - subSubLengthY * ratio_side, ...
                maxSubSubY{iSub}(3) - subSubLengthY * ratio_a, ...
               (maxSubSubY{iSub}(4) + minSubSubY{iSub}(4)) / 2, ...
               (maxSubSubY{iSub}(5) + minSubSubY{iSub}(5)) / 2, ...
               (maxSubSubY{iSub}(6) + minSubSubY{iSub}(6)) / 2, ...
                minSubSubY{iSub}(7) + subSubLengthY * ratio_a, ...
                minSubSubY{iSub}(8) + subSubLengthY * ratio_side, ...
                minSubSubY{iSub}(9) + subSubLengthY * ratio_a];
    %}
    xPosTemp = [...
        maxSubSubX{iSub}(1) - subSubLengthX * ratio_side, ...
        (maxSubSubX{iSub}(2) + minSubSubX{iSub}(2)) / 2, ...
        minSubSubX{iSub}(3) + subSubLengthX * ratio_side, ...
        ...
        maxSubSubX{iSub}(4) - subSubLengthX * ratio_a, ...
        (maxSubSubX{iSub}(5) + minSubSubX{iSub}(5)) / 2, ...
        minSubSubX{iSub}(6) + subSubLengthX * ratio_a, ...
        ...
        maxSubSubX{iSub}(7) - subSubLengthX * ratio_side, ...
        (maxSubSubX{iSub}(8) + minSubSubX{iSub}(8)) / 2, ...
        minSubSubX{iSub}(9) + subSubLengthX * ratio_side];
    
    yPosTemp = [...
        maxSubSubY{iSub}(1) - subSubLengthY * ratio_side, ...
        maxSubSubY{iSub}(2) - subSubLengthY * ratio_a, ...
        maxSubSubY{iSub}(3) - subSubLengthY * ratio_side, ...
        ...
        (maxSubSubY{iSub}(4) + minSubSubY{iSub}(4)) / 2, ...
        (maxSubSubY{iSub}(5) + minSubSubY{iSub}(5)) / 2, ...
        (maxSubSubY{iSub}(6) + minSubSubY{iSub}(6)) / 2, ...
        ...
        minSubSubY{iSub}(7) + subSubLengthY * ratio_side, ...
        minSubSubY{iSub}(8) + subSubLengthY * ratio_a, ...
        minSubSubY{iSub}(9) + subSubLengthY * ratio_side];
    [gammaTemp, thetaTemp] = LocalToGlobal(xPosTemp, yPosTemp);
    constants = Basis(gammaTemp, thetaTemp);
    weightsTemp = Weights(integrations{iSub}, constants);
    
    % Initial residual
    res_a = (surfaceArea{iSub}(5) - weightsTemp(5)) / surfaceArea{iSub}(5);
    
    % Make sure residual is positive
    if res_a < 0
        error('ratio_a gave negative weights!');
    end
    
    % Solve new weights
    %{
    xPosTemp = [maxSubSubX{iSub}(1) - subSubLengthX * ratio_b, ...
        (maxSubSubX{iSub}(2) + minSubSubX{iSub}(2)) / 2, ...
        minSubSubX{iSub}(3) + subSubLengthX * ratio_b, ...
        maxSubSubX{iSub}(4) - subSubLengthX * ratio_side, ...
        (maxSubSubX{iSub}(5) + minSubSubX{iSub}(5)) / 2, ...
        minSubSubX{iSub}(6) + subSubLengthX * ratio_side, ...
        maxSubSubX{iSub}(7) - subSubLengthX * ratio_b, ...
        (maxSubSubX{iSub}(8) + minSubSubX{iSub}(8)) / 2, ...
        minSubSubX{iSub}(9) + subSubLengthX* ratio_b];
    yPosTemp = [maxSubSubY{iSub}(1) - subSubLengthY * ratio_b, ...
        maxSubSubY{iSub}(2) - subSubLengthY * ratio_side, ...
        maxSubSubY{iSub}(3) - subSubLengthY * ratio_b, ...
        (maxSubSubY{iSub}(4) + minSubSubY{iSub}(4)) / 2, ...
        (maxSubSubY{iSub}(5) + minSubSubY{iSub}(5)) / 2, ...
        (maxSubSubY{iSub}(6) + minSubSubY{iSub}(6)) / 2, ...
        minSubSubY{iSub}(7) + subSubLengthY * ratio_b, ...
        minSubSubY{iSub}(8) + subSubLengthY * ratio_side, ...
        minSubSubY{iSub}(9) + subSubLengthY * ratio_b];
    %}
    xPosTemp = [...
        maxSubSubX{iSub}(1) - subSubLengthX * ratio_side, ...
        (maxSubSubX{iSub}(2) + minSubSubX{iSub}(2)) / 2, ...
        minSubSubX{iSub}(3) + subSubLengthX * ratio_side, ...
        ...
        maxSubSubX{iSub}(4) - subSubLengthX * ratio_b, ...
        (maxSubSubX{iSub}(5) + minSubSubX{iSub}(5)) / 2, ...
        minSubSubX{iSub}(6) + subSubLengthX * ratio_b, ...
        ...
        maxSubSubX{iSub}(7) - subSubLengthX * ratio_side, ...
        (maxSubSubX{iSub}(8) + minSubSubX{iSub}(8)) / 2, ...
        minSubSubX{iSub}(9) + subSubLengthX * ratio_side];
    
    yPosTemp = [...
        maxSubSubY{iSub}(1) - subSubLengthY * ratio_side, ...
        maxSubSubY{iSub}(2) - subSubLengthY * ratio_b, ...
        maxSubSubY{iSub}(3) - subSubLengthY * ratio_side, ...
        ...
        (maxSubSubY{iSub}(4) + minSubSubY{iSub}(4)) / 2, ...
        (maxSubSubY{iSub}(5) + minSubSubY{iSub}(5)) / 2, ...
        (maxSubSubY{iSub}(6) + minSubSubY{iSub}(6)) / 2, ...
        ...
        minSubSubY{iSub}(7) + subSubLengthY * ratio_side, ...
        minSubSubY{iSub}(8) + subSubLengthY * ratio_b, ...
        minSubSubY{iSub}(9) + subSubLengthY * ratio_side];
    [gammaTemp, thetaTemp] = LocalToGlobal(xPosTemp, yPosTemp);
    constants = Basis(gammaTemp, thetaTemp);
    weightsTemp = Weights(integrations{iSub}, constants);
    
    % Solve new residual
    res_b = (surfaceArea{iSub}(5) - weightsTemp(5)) / surfaceArea{iSub}(5);
    
    % Make sure residual is negative
    if res_b > 0
        error('ratio_b is positive!');
    end
    
    % Iterate until chosen sub-square weight equals its surface area
    counter   = 0;
    converged = 0;
    while converged == 0 && counter < maxCounts
        
        % Calculate next guess
        x = (ratio_b + ratio_a) / 2;
        
        % New weights for next guess
        %{
        xPosTemp = [maxSubSubX{iSub}(1) - subSubLengthX * x, ...
            (maxSubSubX{iSub}(2) + minSubSubX{iSub}(2)) / 2, ...
            minSubSubX{iSub}(3) + subSubLengthX * x, ...
            maxSubSubX{iSub}(4) - subSubLengthX * ratio_side, ...
            (maxSubSubX{iSub}(5) + minSubSubX{iSub}(5)) / 2, ...
            minSubSubX{iSub}(6) + subSubLengthX * ratio_side, ...
            maxSubSubX{iSub}(7) - subSubLengthX * x, ...
            (maxSubSubX{iSub}(8) + minSubSubX{iSub}(8)) / 2, ...
            minSubSubX{iSub}(9) + subSubLengthX* x];
        yPosTemp = [maxSubSubY{iSub}(1) - subSubLengthY * x, ...
            maxSubSubY{iSub}(2) - subSubLengthY * ratio_side, ...
            maxSubSubY{iSub}(3) - subSubLengthY * x, ...
            (maxSubSubY{iSub}(4) + minSubSubY{iSub}(4)) / 2, ...
            (maxSubSubY{iSub}(5) + minSubSubY{iSub}(5)) / 2, ...
            (maxSubSubY{iSub}(6) + minSubSubY{iSub}(6)) / 2, ...
            minSubSubY{iSub}(7) + subSubLengthY * x, ...
            minSubSubY{iSub}(8) + subSubLengthY * ratio_side, ...
            minSubSubY{iSub}(9) + subSubLengthY * x];
        %}
        xPosTemp = [...
            maxSubSubX{iSub}(1) - subSubLengthX * ratio_side, ...
            (maxSubSubX{iSub}(2) + minSubSubX{iSub}(2)) / 2, ...
            minSubSubX{iSub}(3) + subSubLengthX * ratio_side, ...
            ...
            maxSubSubX{iSub}(4) - subSubLengthX * x, ...
            (maxSubSubX{iSub}(5) + minSubSubX{iSub}(5)) / 2, ...
            minSubSubX{iSub}(6) + subSubLengthX * x, ...
            ...
            maxSubSubX{iSub}(7) - subSubLengthX * ratio_side, ...
            (maxSubSubX{iSub}(8) + minSubSubX{iSub}(8)) / 2, ...
            minSubSubX{iSub}(9) + subSubLengthX * ratio_side];
        
        yPosTemp = [...
            maxSubSubY{iSub}(1) - subSubLengthY * ratio_side, ...
            maxSubSubY{iSub}(2) - subSubLengthY * x, ...
            maxSubSubY{iSub}(3) - subSubLengthY * ratio_side, ...
            ...
            (maxSubSubY{iSub}(4) + minSubSubY{iSub}(4)) / 2, ...
            (maxSubSubY{iSub}(5) + minSubSubY{iSub}(5)) / 2, ...
            (maxSubSubY{iSub}(6) + minSubSubY{iSub}(6)) / 2, ...
            ...
            minSubSubY{iSub}(7) + subSubLengthY * ratio_side, ...
            minSubSubY{iSub}(8) + subSubLengthY * x, ...
            minSubSubY{iSub}(9) + subSubLengthY * ratio_side];
        [gammaTemp, thetaTemp] = LocalToGlobal(xPosTemp, yPosTemp);
        constants = Basis(gammaTemp, thetaTemp);
        weightsTemp = Weights(integrations{iSub}, constants);
        
        % New residual
        res_x = (surfaceArea{iSub}(5) - weightsTemp(5)) / surfaceArea{iSub}(5);
        
        % Ensure residuals are not equal
        if res_a == res_b
            error('Error: residuals are equal');
        else
            
            % Check for convergence
            if abs(ratio_a - ratio_b) < areaEps
                converged = 1;
            else
                
                % If the residual of next guess has same sign as a
                if res_x / res_a > 0
                    
                    % New a ratio
                    ratio_a = x;
                    
                    % New a residual
                    res_a = res_x;
                    
                else
                    
                    % New b ratio
                    ratio_b = x;
                    
                    % New b residual
                    res_b = res_x;
                    
                end
                
                % Update counter
                counter = counter + 1;
                
            end
        end
    end
    
    % Check for failure
    if converged == 0
        error('Error: QDFE-ratio failed!');
    end
    
    % Store quadrature data
    xPos{iSub}     = xPosTemp;
    yPos{iSub}     = yPosTemp;
    gamma{iSub, 1} = gammaTemp;
    theta{iSub, 1} = thetaTemp;
    weights{iSub}  = weightsTemp;
    
    ratioPlot(counterPlot) = ratio_a;
    errorPlot(counterPlot) = res_x;
    counterPlot = counterPlot + 1;
end

% Normalize weights to 4pi
tot_weight = 0;
counter = 1;
for i = 1 : (iRef + 1) ^ 2
    for j = 1 : 9
        tot_weight = tot_weight + weights{i}(j);
        counter = counter + 1;
    end
end
norm = (4 * pi / 24) / tot_weight;
for i = 1 : (iRef + 1) ^ 2
    for j = 1 : 9
        weights{i}(j) = weights{i}(j) * norm;
    end
end

% Maximum surface area error
test = zeros((iRef + 1) ^ 2, 1);
counter = 1;
for i = 1 : (iRef + 1) ^ 2
    test(counter) = abs(weights{i}(5) - surfaceArea{i}(5)) / surfaceArea{i}(5);
    counter = counter + 1;
end
fprintf('the maximum error is: %E \n', max(test));
fprintf('the average error is: %E \n', mean(test));

% Rotate to other three faces
for i = 1 : (iRef + 1) ^ 2
    for j = 1 : 9
        gamma{i, 2}(j) = (pi / 2) - atan(sqrt(3) * yPos{i}(j));
        theta{i, 2}(j) = (pi / 2) - atan(sqrt(3) * xPos{i}(j) / sqrt(1 + 3 * yPos{i}(j) ^ 2));
        gamma{i, 3}(j) = atan(yPos{i}(j) / xPos{i}(j));
        theta{i, 3}(j) = (pi / 2) - atan(1 / (sqrt(3) * sqrt(yPos{i}(j) ^ 2 + xPos{i}(j) ^ 2)));
    end
end

% Store QDFE-ratio quadrature data
quadrature.gamma   = gamma;
quadrature.theta   = theta;
quadrature.weights = weights;

end